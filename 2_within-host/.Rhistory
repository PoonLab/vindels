# total <- c()
# for (i in 1:50){
# SIMULATE TIP + ANCESTOR SEQUENCES
simSeqs <- function(iter, param){
all.seqs <- sapply(1:iter, function(n){
if (n %% 1000 == 0 ){
print(n)
}
pair <- simPair(param)
# VALUE 1 = Tip, VALUE 2 = Ancestor, VALUE 3 = Branch length
return(c(pair[[1]], pair[[2]], pair[[3]], pair[[4]]))
})
insertions <- as.data.frame(t(all.seqs), stringsAsFactors = F)
colnames(insertions) <- c("tip", "anc", "branch", 'no.filter')
# Generate the length and position columns
data <- t(unname(sapply(insertions$anc, function(x){
# returns c(length, position) of insertion events
gaps <- gregexpr("-",x)[[1]]
if (length(gaps) == 1 && gaps == -1){
return (c(NA, NA))
}else{
return (c(length(gaps), max(gaps)))
}
})))
insertions$len <- data[,1]
insertions$pos <- data[,2]
return(insertions)
}
# ----- Fixation Parameter Testing -----
t <- sum(as.numeric(insertions$no.filter))
all.len <- insertions[!is.na(insertions$len), 'len']
a <- sum(all.len %% 3 == 0)
b <- sum(all.len %% 3 != 0)
#prop[i] <- a / (b / 0.09 + a)
total[i] <- t
avec[i] <- a
bvec[i] <- b
#}
all.len <- insertions[!is.na(insertions$len), 'len']
#filt.len <- new.ins[!is.na(new.ins$len), 'len']
sum(all.len %% 3 == 0)
sum(all.len %% 3 != 0)
x <- sum(filt.len %% 3 == 0)
vec[i] <- sum(filt.len %% 3 != 0) / ((x / 0.276) - x)
#}
# ---- Geometric Distribution Calibration -----
calib <- c()
values <- seq(0.05, 0.25, 0.01)
for (n in 1:length(values)){
vec <- c()
for (i in 1:500){
x <- round(rgeom(1000, values[n]))
x <- x[x>0]
vec[i] <- sum(x%%3==0) / 1000
}
calib[n] <- median(vec)
}
rm(vec)
#  ---- Start MCMC ----
param <- c(0.00052,0.85, 0.00001, 0.09)
insertions <- simSeqs(25000, param)
setup(insertions$tip, insertions$anc, insertions$len, insertions$pos, insertions$branch, F)
startvalue <- c(0.0008, 0.65, 0.000001, 0.25)
notes <- "Test # 18
Added in binomial likelihood function to describe the fixation parameter
truevalues:(0.00052, 0.85, 0.00001, 0.09)
startvalues:(0.0008, 0.65, 0.000001, 0.25)
priors: all uninformative, uniform, broad, except fixation
shuffle: off
"
notes
param
insertions
startvalue
a
b
non3
(1 - sum(dgeom(non3-1, (1-p.stay))))
(1 - sum(dgeom(non3-1, (1-p.stay)))
start.time <- proc.time()
# initialize the chain
chain <- array(dim = c(iterations+1,4))
chain[1,] <- startvalue
# start the slip list and the llh list
slip_current <- slip.list
llh_current <- seqllh(startvalue[3], slip.list)
slip_current <- slip.list
llh_current <- seqllh(startvalue[3], slip.list)
sum(dgeom(non3-1, (1-p.stay)))
param
sum(dgeom(non3-1, (1-param[2])))
param[2]
est.non3 <- sum(dgeom(non3-1, (1-param[2])))
est.non3 <- round((a / (1 - sum(dgeom(non3-1, (1-p.stay))))) - a)
est.non3 <- round((a / (1 - sum(dgeom(non3-1, (1-param[2]))))) - a)
est.non3
llh.fix <- dbinom(b, est.non3, param[4])    # mean=est.fix, sd=0.005, log=T)
llh.fix
setwd("~/vindels/2_within-host/")
require(bbmle)
require(stringr)
require(ape)
require(phangorn)
require(data.table)
source("~/vindels/2_within-host/utils.r")
# Lio
path <- "~/PycharmProjects/hiv-withinhost/"
#path <- "~/Lio/"
ifolder <- Sys.glob(paste0(path,"9Indels/mcc/wholetree/ins/*.tsv"))
dfolder <- Sys.glob(paste0(path,"9Indels/mcc/wholetree/del/*.tsv"))
all.ins <-list()
all.del <- list()
count <- 0
ins.nosep <- list()
del.nosep <- list()
for (file in 1:length(ifolder)){
print(file)
filename <- basename(ifolder[file])
iCSV <- read.csv(ifolder[file], stringsAsFactors = F, sep="\t")
dCSV <- read.csv(dfolder[file], stringsAsFactors = F, sep="\t")
# extracts info from the indel column and puts it into two separate columns
insInfo <- sapply(iCSV$indel, extractInfo)
insInfo <- unname(insInfo)
insInfo <- t(insInfo)
insInfo <- as.data.frame(insInfo)
insInfo$V1 <- as.character(insInfo$V1)
insInfo$V2 <- as.character(insInfo$V2)
iCSV <- cbind(iCSV, insInfo)
iCSV$indel <- NULL
delInfo <- sapply(dCSV$indel, extractInfo)
delInfo <- unname(delInfo)
delInfo <- t(delInfo)
delInfo <- as.data.frame(delInfo)
delInfo$V1 <- as.character(delInfo$V1)
delInfo$V2 <- as.character(delInfo$V2)
dCSV <- cbind(dCSV, delInfo)
dCSV$indel <- NULL
if(all(is.na(iCSV$V1))){
iCSV$V1 <- ""
iCSV$V2 <- ""
}
iCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(iCSV))
dCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(dCSV))
# Load time-based branch lengths from the time-scaled trees
tre <- read.tree(paste0(path,"7_5_MCC/prelim/", strsplit(filename, "\\.tsv")[[1]], ".tree"))
# remove the root from the rtt length vector because it is NOT found in the reconstruction or the indel extraction (deprecated)
#lens <- lens[-(Ntip(tre)+1)]
res <- unname(sapply(iCSV$header, function(x){
# this expression will return results for NODES ONLY
# second column provides the CAPTURED TIP LABELS from within the node label
x <- substr(x, 1, nchar(x)-2)
tips <- str_match_all(x,"([^\\)\\(,\n:]+):")[[1]][,2]
if (length(tips) == 0){
# no colons; this means its a TIP
# the index in the tre$tip.label vector is the final result
index <- match(x, tre$tip.label)
}else{
# retreive all descendants of every node and tip in the tree
desc <- Descendants(tre)
# find the numeric labels of all extracted tips
matches <- match(tips, tre$tip.label)
# find the SINGLE node in the descendants list that contains the exact same subset of tips
index <- which(sapply(desc, function(x){ifelse(length(x) == length(matches) && all(x==matches),T,F)}))
}
if (length(index)!=1){
return(paste0("PROBLEM:",as.character(index)))
}
return(c(index))
}))
iCSV$length <- tre$edge.length[match(res, tre$edge[,2])]
dCSV$length <- iCSV$length
# lens <- node.depth.edgelength(tre)
# iCSV$rtt.mid <- (lens[res] + lens[tre$edge[match(res, tre$edge[,2]),1]]) / 2
# dCSV$rtt.mid <- iCSV$rtt.mid
iCSV$count <- unname(sapply(iCSV$V1, csvcount))
dCSV$count <- unname(sapply(dCSV$V1, csvcount))
iCSV$header <- unname(mapply(labels, iCSV$header, iCSV$pat))
dCSV$header <- unname(mapply(labels, dCSV$header, dCSV$pat))
iCSV <- iCSV[,c(1,2,3,9,10,6,7,4,5,8)]
dCSV <- dCSV[,c(1,2,3,9,10,6,7,4,5,8)]
colnames(iCSV) <- c("header","vloop", "vlen", "length","count", "indel", "pos", "tip","anc","pat")
colnames(dCSV) <- c("header", "vloop", "vlen", "length","count",  "indel", "pos", "tip","anc","pat")
ins.nosep[[file]] <-  iCSV
del.nosep[[file]] <-  dCSV
# COMMA SEPARATION FIX
# make a new data.frame for each CSV df
# transport over all rows which do NOT contain a comma
ins.sep <- iCSV[!grepl(",",iCSV$indel),]
del.sep <- dCSV[!grepl(",",dCSV$indel),]
# handle comma rows separately with a function
iCommas <- iCSV[grepl(",",iCSV$indel),]
dCommas <- dCSV[grepl(",",dCSV$indel),]
# APPLY THE SPLIT ROWS TO GET ONE INDEL PER ROW
if (nrow(iCommas) > 0){
newrows <- apply(iCommas,1,splitRows, c(6,7))
for (i in 1:length(newrows)){
idx <- as.double(names(newrows)[i])
len <- nrow(newrows[[i]])
rownames(newrows[[i]]) <- seq(0,0.1*(len-1),length=len) + idx
ins.sep <- rbind(ins.sep, newrows[[i]])
}
}
if (nrow(dCommas) > 0){
newrows <- apply(dCommas,1,splitRows, c(6,7))
for (i in 1:length(newrows)){
idx <- as.double(names(newrows)[i])
len <- nrow(newrows[[i]])
rownames(newrows[[i]]) <- seq(0,0.1*(len-1),length=len) + idx
del.sep <- rbind(del.sep, newrows[[i]])
}
}
# Add the V position column into the two final data frames
#ins.sep$vpos <- as.numeric(unname(mapply(addPos, pos=ins.sep$pos, header=ins.sep$header, vloop=ins.sep$vloop)))
#del.sep$vpos <- as.numeric(unname(mapply(addPos, pos=del.sep$pos, header=del.sep$header, vloop=del.sep$vloop)))
# OUTPUT
# for other analyses
# -----------------------------
all.ins[[file]] <- ins.sep
all.del[[file]] <- del.sep
}
all.ins <- as.data.frame(rbindlist(all.ins))
all.del <- as.data.frame(rbindlist(all.del))
ins.nosep <- as.data.frame(rbindlist(ins.nosep))
del.nosep <- as.data.frame(rbindlist(del.nosep))
ins <- all.ins[all.ins$indel!="",]
del <- all.del[all.del$indel!="",]
file
print(file)
filename <- basename(ifolder[file])
iCSV <- read.csv(ifolder[file], stringsAsFactors = F, sep="\t")
dCSV <- read.csv(dfolder[file], stringsAsFactors = F, sep="\t")
# extracts info from the indel column and puts it into two separate columns
insInfo <- sapply(iCSV$indel, extractInfo)
insInfo <- unname(insInfo)
insInfo <- t(insInfo)
insInfo <- as.data.frame(insInfo)
insInfo$V1 <- as.character(insInfo$V1)
insInfo$V2 <- as.character(insInfo$V2)
iCSV <- cbind(iCSV, insInfo)
iCSV$indel <- NULL
delInfo <- sapply(dCSV$indel, extractInfo)
delInfo <- unname(delInfo)
delInfo <- t(delInfo)
delInfo <- as.data.frame(delInfo)
delInfo$V1 <- as.character(delInfo$V1)
delInfo$V2 <- as.character(delInfo$V2)
dCSV <- cbind(dCSV, delInfo)
dCSV$indel <- NULL
head(iCSV)
if(all(is.na(iCSV$V1))){
iCSV$V1 <- ""
iCSV$V2 <- ""
}
iCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(iCSV))
dCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(dCSV))
# Load time-based branch lengths from the time-scaled trees
tre <- read.tree(paste0(path,"7_5_MCC/prelim/", strsplit(filename, "\\.tsv")[[1]], ".tree"))
strsplit(filename, "\\.tsv")[[1]]
path
paste0(path,"7_5_MCC/prelim/", strsplit(filename, "\\.tsv")[[1]], ".tree")
# Load time-based branch lengths from the time-scaled trees
tre <- read.nexus(paste0(path,"7_5_MCC/prelim/", strsplit(filename, "\\.tsv")[[1]], ".tree"))
tre
require(bbmle)
require(stringr)
require(ape)
require(phangorn)
require(data.table)
source("~/vindels/2_within-host/utils.r")
# Lio
path <- "~/PycharmProjects/hiv-withinhost/"
#path <- "~/Lio/"
ifolder <- Sys.glob(paste0(path,"9Indels/mcc/wholetree/ins/*.tsv"))
dfolder <- Sys.glob(paste0(path,"9Indels/mcc/wholetree/del/*.tsv"))
all.ins <-list()
all.del <- list()
count <- 0
ins.nosep <- list()
del.nosep <- list()
for (file in 1:length(ifolder)){
print(file)
filename <- basename(ifolder[file])
iCSV <- read.csv(ifolder[file], stringsAsFactors = F, sep="\t")
dCSV <- read.csv(dfolder[file], stringsAsFactors = F, sep="\t")
# extracts info from the indel column and puts it into two separate columns
insInfo <- sapply(iCSV$indel, extractInfo)
insInfo <- unname(insInfo)
insInfo <- t(insInfo)
insInfo <- as.data.frame(insInfo)
insInfo$V1 <- as.character(insInfo$V1)
insInfo$V2 <- as.character(insInfo$V2)
iCSV <- cbind(iCSV, insInfo)
iCSV$indel <- NULL
delInfo <- sapply(dCSV$indel, extractInfo)
delInfo <- unname(delInfo)
delInfo <- t(delInfo)
delInfo <- as.data.frame(delInfo)
delInfo$V1 <- as.character(delInfo$V1)
delInfo$V2 <- as.character(delInfo$V2)
dCSV <- cbind(dCSV, delInfo)
dCSV$indel <- NULL
if(all(is.na(iCSV$V1))){
iCSV$V1 <- ""
iCSV$V2 <- ""
}
iCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(iCSV))
dCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(dCSV))
# Load time-based branch lengths from the time-scaled trees
tre <- read.nexus(paste0(path,"7_5_MCC/prelim/", strsplit(filename, "\\.tsv")[[1]], ".tree"))
# remove the root from the rtt length vector because it is NOT found in the reconstruction or the indel extraction (deprecated)
#lens <- lens[-(Ntip(tre)+1)]
res <- unname(sapply(iCSV$header, function(x){
# this expression will return results for NODES ONLY
# second column provides the CAPTURED TIP LABELS from within the node label
x <- substr(x, 1, nchar(x)-2)
tips <- str_match_all(x,"([^\\)\\(,\n:]+):")[[1]][,2]
if (length(tips) == 0){
# no colons; this means its a TIP
# the index in the tre$tip.label vector is the final result
index <- match(x, tre$tip.label)
}else{
# retreive all descendants of every node and tip in the tree
desc <- Descendants(tre)
# find the numeric labels of all extracted tips
matches <- match(tips, tre$tip.label)
# find the SINGLE node in the descendants list that contains the exact same subset of tips
index <- which(sapply(desc, function(x){ifelse(length(x) == length(matches) && all(x==matches),T,F)}))
}
if (length(index)!=1){
return(paste0("PROBLEM:",as.character(index)))
}
return(c(index))
}))
iCSV$length <- tre$edge.length[match(res, tre$edge[,2])]
dCSV$length <- iCSV$length
# lens <- node.depth.edgelength(tre)
# iCSV$rtt.mid <- (lens[res] + lens[tre$edge[match(res, tre$edge[,2]),1]]) / 2
# dCSV$rtt.mid <- iCSV$rtt.mid
iCSV$count <- unname(sapply(iCSV$V1, csvcount))
dCSV$count <- unname(sapply(dCSV$V1, csvcount))
iCSV$header <- unname(mapply(labels, iCSV$header, iCSV$pat))
dCSV$header <- unname(mapply(labels, dCSV$header, dCSV$pat))
iCSV <- iCSV[,c(1,2,3,9,10,6,7,4,5,8)]
dCSV <- dCSV[,c(1,2,3,9,10,6,7,4,5,8)]
colnames(iCSV) <- c("header","vloop", "vlen", "length","count", "indel", "pos", "tip","anc","pat")
colnames(dCSV) <- c("header", "vloop", "vlen", "length","count",  "indel", "pos", "tip","anc","pat")
ins.nosep[[file]] <-  iCSV
del.nosep[[file]] <-  dCSV
# COMMA SEPARATION FIX
# make a new data.frame for each CSV df
# transport over all rows which do NOT contain a comma
ins.sep <- iCSV[!grepl(",",iCSV$indel),]
del.sep <- dCSV[!grepl(",",dCSV$indel),]
# handle comma rows separately with a function
iCommas <- iCSV[grepl(",",iCSV$indel),]
dCommas <- dCSV[grepl(",",dCSV$indel),]
# APPLY THE SPLIT ROWS TO GET ONE INDEL PER ROW
if (nrow(iCommas) > 0){
newrows <- apply(iCommas,1,splitRows, c(6,7))
for (i in 1:length(newrows)){
idx <- as.double(names(newrows)[i])
len <- nrow(newrows[[i]])
rownames(newrows[[i]]) <- seq(0,0.1*(len-1),length=len) + idx
ins.sep <- rbind(ins.sep, newrows[[i]])
}
}
if (nrow(dCommas) > 0){
newrows <- apply(dCommas,1,splitRows, c(6,7))
for (i in 1:length(newrows)){
idx <- as.double(names(newrows)[i])
len <- nrow(newrows[[i]])
rownames(newrows[[i]]) <- seq(0,0.1*(len-1),length=len) + idx
del.sep <- rbind(del.sep, newrows[[i]])
}
}
# Add the V position column into the two final data frames
#ins.sep$vpos <- as.numeric(unname(mapply(addPos, pos=ins.sep$pos, header=ins.sep$header, vloop=ins.sep$vloop)))
#del.sep$vpos <- as.numeric(unname(mapply(addPos, pos=del.sep$pos, header=del.sep$header, vloop=del.sep$vloop)))
# OUTPUT
# for other analyses
# -----------------------------
all.ins[[file]] <- ins.sep
all.del[[file]] <- del.sep
}
require(bbmle)
require(stringr)
require(ape)
require(phangorn)
require(data.table)
source("~/vindels/2_within-host/utils.r")
# Lio
path <- "~/PycharmProjects/hiv-withinhost/"
#path <- "~/Lio/"
ifolder <- Sys.glob(paste0(path,"9Indels/mcc/wholetree/ins/*.tsv"))
dfolder <- Sys.glob(paste0(path,"9Indels/mcc/wholetree/del/*.tsv"))
all.ins <-list()
all.del <- list()
count <- 0
ins.nosep <- list()
del.nosep <- list()
for (file in 1:length(ifolder)){
print(file)
filename <- basename(ifolder[file])
iCSV <- read.csv(ifolder[file], stringsAsFactors = F, sep="\t")
dCSV <- read.csv(dfolder[file], stringsAsFactors = F, sep="\t")
# extracts info from the indel column and puts it into two separate columns
insInfo <- sapply(iCSV$indel, extractInfo)
insInfo <- unname(insInfo)
insInfo <- t(insInfo)
insInfo <- as.data.frame(insInfo)
insInfo$V1 <- as.character(insInfo$V1)
insInfo$V2 <- as.character(insInfo$V2)
iCSV <- cbind(iCSV, insInfo)
iCSV$indel <- NULL
delInfo <- sapply(dCSV$indel, extractInfo)
delInfo <- unname(delInfo)
delInfo <- t(delInfo)
delInfo <- as.data.frame(delInfo)
delInfo$V1 <- as.character(delInfo$V1)
delInfo$V2 <- as.character(delInfo$V2)
dCSV <- cbind(dCSV, delInfo)
dCSV$indel <- NULL
if(all(is.na(iCSV$V1))){
iCSV$V1 <- ""
iCSV$V2 <- ""
}
iCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(iCSV))
dCSV$pat <- rep(strsplit(filename, "\\.")[[1]][1], nrow(dCSV))
# Load time-based branch lengths from the time-scaled trees
tre <- read.tree(paste0(path,"7_5_MCC/prelim/", strsplit(filename, "\\.tsv")[[1]], ".tree"))
# remove the root from the rtt length vector because it is NOT found in the reconstruction or the indel extraction (deprecated)
#lens <- lens[-(Ntip(tre)+1)]
res <- unname(sapply(iCSV$header, function(x){
# this expression will return results for NODES ONLY
# second column provides the CAPTURED TIP LABELS from within the node label
x <- substr(x, 1, nchar(x)-2)
tips <- str_match_all(x,"([^\\)\\(,\n:]+):")[[1]][,2]
if (length(tips) == 0){
# no colons; this means its a TIP
# the index in the tre$tip.label vector is the final result
index <- match(x, tre$tip.label)
}else{
# retreive all descendants of every node and tip in the tree
desc <- Descendants(tre)
# find the numeric labels of all extracted tips
matches <- match(tips, tre$tip.label)
# find the SINGLE node in the descendants list that contains the exact same subset of tips
index <- which(sapply(desc, function(x){ifelse(length(x) == length(matches) && all(x==matches),T,F)}))
}
if (length(index)!=1){
return(paste0("PROBLEM:",as.character(index)))
}
return(c(index))
}))
iCSV$length <- tre$edge.length[match(res, tre$edge[,2])]
dCSV$length <- iCSV$length
# lens <- node.depth.edgelength(tre)
# iCSV$rtt.mid <- (lens[res] + lens[tre$edge[match(res, tre$edge[,2]),1]]) / 2
# dCSV$rtt.mid <- iCSV$rtt.mid
iCSV$count <- unname(sapply(iCSV$V1, csvcount))
dCSV$count <- unname(sapply(dCSV$V1, csvcount))
iCSV$header <- unname(mapply(labels, iCSV$header, iCSV$pat))
dCSV$header <- unname(mapply(labels, dCSV$header, dCSV$pat))
iCSV <- iCSV[,c(1,2,3,9,10,6,7,4,5,8)]
dCSV <- dCSV[,c(1,2,3,9,10,6,7,4,5,8)]
colnames(iCSV) <- c("header","vloop", "vlen", "length","count", "indel", "pos", "tip","anc","pat")
colnames(dCSV) <- c("header", "vloop", "vlen", "length","count",  "indel", "pos", "tip","anc","pat")
ins.nosep[[file]] <-  iCSV
del.nosep[[file]] <-  dCSV
# COMMA SEPARATION FIX
# make a new data.frame for each CSV df
# transport over all rows which do NOT contain a comma
ins.sep <- iCSV[!grepl(",",iCSV$indel),]
del.sep <- dCSV[!grepl(",",dCSV$indel),]
# handle comma rows separately with a function
iCommas <- iCSV[grepl(",",iCSV$indel),]
dCommas <- dCSV[grepl(",",dCSV$indel),]
# APPLY THE SPLIT ROWS TO GET ONE INDEL PER ROW
if (nrow(iCommas) > 0){
newrows <- apply(iCommas,1,splitRows, c(6,7))
for (i in 1:length(newrows)){
idx <- as.double(names(newrows)[i])
len <- nrow(newrows[[i]])
rownames(newrows[[i]]) <- seq(0,0.1*(len-1),length=len) + idx
ins.sep <- rbind(ins.sep, newrows[[i]])
}
}
if (nrow(dCommas) > 0){
newrows <- apply(dCommas,1,splitRows, c(6,7))
for (i in 1:length(newrows)){
idx <- as.double(names(newrows)[i])
len <- nrow(newrows[[i]])
rownames(newrows[[i]]) <- seq(0,0.1*(len-1),length=len) + idx
del.sep <- rbind(del.sep, newrows[[i]])
}
}
# Add the V position column into the two final data frames
#ins.sep$vpos <- as.numeric(unname(mapply(addPos, pos=ins.sep$pos, header=ins.sep$header, vloop=ins.sep$vloop)))
#del.sep$vpos <- as.numeric(unname(mapply(addPos, pos=del.sep$pos, header=del.sep$header, vloop=del.sep$vloop)))
# OUTPUT
# for other analyses
# -----------------------------
all.ins[[file]] <- ins.sep
all.del[[file]] <- del.sep
}
all.ins <- as.data.frame(rbindlist(all.ins))
all.del <- as.data.frame(rbindlist(all.del))
ins.nosep <- as.data.frame(rbindlist(ins.nosep))
del.nosep <- as.data.frame(rbindlist(del.nosep))
ins <- all.ins[all.ins$indel!="",]
del <- all.del[all.del$indel!="",]
head(ins)
